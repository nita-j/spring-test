@Repository
public class ProductRepository {

    @Autowired
    private MongoTemplate mongoTemplate;

    public List<Product> findProductsByStatusAndDateRange(String status, String productType, Date startDate, Date endDate) {

        // Stage 1: Match status and product type
        MatchOperation matchStatusAndType = Aggregation.match(
                Criteria.where("status").in("active", "approved", "rejected")
                        .and("productType").is(productType)
        );

        // Stage 2: Add computed field `filterDate` based on status
        AddFieldsOperation addFilterDate = context -> new Document("$addFields",
                new Document("filterDate",
                    new Document("$switch",
                        new Document("branches", List.of(
                            new Document("case", new Document("$eq", List.of("$status", "active")))
                                .append("then", "$creationDate"),
                            new Document("case", new Document("$eq", List.of("$status", "approved")))
                                .append("then", "$approvalDate"),
                            new Document("case", new Document("$eq", List.of("$status", "rejected")))
                                .append("then", "$rejectedDate")
                        )).append("default", null)
                    )
                )
        );

        // Stage 3: Match on filterDate
        MatchOperation matchDateRange = Aggregation.match(
                Criteria.where("filterDate").gte(startDate).lte(endDate)
        );

        // Stage 4: Optional - Remove filterDate from final result
        ProjectionOperation projectFinal = Aggregation.project().andExclude("filterDate");

        Aggregation aggregation = Aggregation.newAggregation(
                matchStatusAndType,
                addFilterDate,
                matchDateRange,
                projectFinal
        );

        return mongoTemplate.aggregate(aggregation, "products", Product.class).getMappedResults();
    }
}
